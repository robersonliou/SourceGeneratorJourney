using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SourceGeneratorLib.Extensions;
using SourceGeneratorLib.SyntaxReceivers;

namespace SourceGeneratorLib.Generators
{
    [Generator]
    class MapperGenerator : ISourceGenerator
    {

        private const string NameSpace = "NetConf2020";
        private const string AttributeName = "Mapping";
        
        public void Initialize(GeneratorInitializationContext context)
        {
            if (!context.CancellationToken.IsCancellationRequested)
            {
                #region manully toggle debugger
                // Debugger.Launch();
                #endregion
                context.RegisterForSyntaxNotifications(() => new MappingSyntaxReceiver());
            }
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!context.CancellationToken.IsCancellationRequested)
            {
                var attributeText = $@"
{SharedMeta.GeneratedByDataBuilderGeneratorPreamble}
using System;
namespace {NameSpace}
{{
    public class {AttributeName}Attribute : Attribute
    {{
        public {AttributeName}Attribute(Type targetType)
        {{
            this.TargetType = targetType;
        }}

        public Type TargetType {{ get; set; }}
    }}
}}";
                if (context.SyntaxReceiver is MappingSyntaxReceiver)
                {
                    context.AddSource("MappingAttribute", SourceText.From(attributeText, Encoding.UTF8));

                    //Create a new compilation that contains the attribute
                    var options =
                        (context.Compilation as CSharpCompilation).SyntaxTrees[0].Options as CSharpParseOptions;
                    var compilation = context.Compilation.AddSyntaxTrees(
                        CSharpSyntaxTree.ParseText(SourceText.From(attributeText, Encoding.UTF8), options));

                    //todo: retrieve source and target type by MapperAttribute
                    var allNodes = compilation.SyntaxTrees.SelectMany(s => s.GetRoot().DescendantNodes());
                    var allAttributes = allNodes.Where((d) => d.IsKind(SyntaxKind.Attribute)).OfType<AttributeSyntax>();
                    var attributes = allAttributes.Where(d => d.Name.ToString() == "Mapping"
                                                              || d.Name.ToString() == "MapperGenerator.Mapping")
                        .ToImmutableArray();
                    var allClasses = compilation.SyntaxTrees.SelectMany(x =>
                        x.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>());

                    var sourceBuilder = new StringBuilder(@"
//<auto-generated>
using System;
namespace MapperGenerator
{
    public static class Mapper
    {");

                    foreach (var attr in attributes)
                    {
                        if (attr.ArgumentList is null) throw new Exception("Can't be null here");

                        #region Get Mapping Source Class Info

                        //todo: add diagnostic when ArgumentList is null
                        //take the first argument in constructor of attribute 
                        var firstArgument = attr.ArgumentList.Arguments.First();

                        var argumentExpression = firstArgument.Expression.NormalizeWhitespace().ToFullString();

                        var sourceClassName = GetContentInParentheses(argumentExpression);
                        var sourceClassSyntax = allClasses.First(x => x.Identifier.ToString() == sourceClassName);
                        var sourceClassModel = compilation.GetSemanticModel(sourceClassSyntax.SyntaxTree);
                        var sourceClassNamedTypeSymbol = sourceClassModel.GetDeclaredSymbol(sourceClassSyntax);
                        var sourceClassFullName = sourceClassNamedTypeSymbol.OriginalDefinition.ToString();
                        var sourceClassProperties = sourceClassSyntax.GetProperties(sourceClassModel);

                        #endregion

                        #region Get Mapping Target Class Info

                        var targetClassSyntax = attr.SyntaxTree.GetRoot().DescendantNodes()
                            .OfType<ClassDeclarationSyntax>().Last();
                        var targetClassModel = compilation.GetSemanticModel(attr.SyntaxTree);
                        var targetClassNamedTypeSymbol = targetClassModel.GetDeclaredSymbol(targetClassSyntax);
                        var targetClassFullName = targetClassNamedTypeSymbol.OriginalDefinition.ToString();
                        var targetClassName = targetClassFullName.Split('.').Last();
                        var targetClassProperties = targetClassSyntax.GetProperties(targetClassModel);

                        #endregion

                        #region Throw Exception if any property of target doesn't match to source properties.

                        //source class properties should match all of target class properties
                        //should use same name and type of property
                        var targetPropertiesMatchedResult = targetClassProperties.Select(target => new
                        {
                            TargetPropertyName = target.propertyName,
                            TargetPropertySyntax = target.propertySyntax,
                            IsMatched = sourceClassProperties.Any(source =>
                                source.propertyName == target.propertyName &&
                                source.propertyType == target.propertyType)
                        });
                        if (targetPropertiesMatchedResult.Any(x => x.IsMatched == false))
                        {
                            foreach (var target in targetPropertiesMatchedResult.Where(x => x.IsMatched == false))
                            {
                                var diagnosticDescriptor = new DiagnosticDescriptor("MPERR001",
                                    "Property mapping error",
                                    $"{targetClassName}.{target.TargetPropertyName} couldn't match to {sourceClassName}, please check if the name and type of properties are the same.",
                                    "source generator",
                                    DiagnosticSeverity.Error, true);
                                var diagnostic = Diagnostic.Create(diagnosticDescriptor,
                                    target.TargetPropertySyntax.GetLocation());
                                context.ReportDiagnostic(diagnostic);
                            }

                            break;
                        }

                        #endregion

                        #region Build mapper method

                        sourceBuilder.Append(@$"
            public static {targetClassFullName} MapTo{targetClassName}({sourceClassFullName} source)
            {{
                var target = new {targetClassFullName}();");

                        foreach (var (_, propertyName, _) in targetClassProperties)
                        {
                            sourceBuilder.Append(@$"
                target.{propertyName} = source.{propertyName};");
                        }


                        sourceBuilder.Append(@"
                return target;
            }
    ");
                        sourceBuilder.Append(@$"
            public static {targetClassFullName} To{targetClassName}(this {sourceClassFullName} source)
            {{
                var target = new {targetClassFullName}();");

                        foreach (var (_, propertyName, _) in targetClassProperties)
                        {
                            sourceBuilder.Append(@$"
                target.{propertyName} = source.{propertyName};");
                        }


                        sourceBuilder.Append(@"
                return target;
            }
    ");

                        #endregion
                    }

                    sourceBuilder.Append(@"
    }
}");

                    var text = sourceBuilder.ToString();
                    context.AddSource("GeneratorMapper", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
                }
            }
        }

        private string GetContentInParentheses(string value)
        {
            var match = Regex.Match(value, @"\(([^)]*)\)");
            return match.Groups[1].Value;
        }
    }
}
